<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>水面の揺らぎエフェクト</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: inline-block;
            width: 140px;
            font-size: 12px;
        }
        .control-group input {
            width: 100px;
            margin-right: 5px;
        }
        .control-group span {
            font-size: 12px;
            width: 40px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>水面パラメータ</h3>
        <div class="control-group">
            <label>基本色 (R):</label>
            <input type="range" id="baseColorR" min="0" max="255" value="0">
            <span id="baseColorRValue">0</span>
        </div>
        <div class="control-group">
            <label>基本色 (G):</label>
            <input type="range" id="baseColorG" min="0" max="255" value="150">
            <span id="baseColorGValue">150</span>
        </div>
        <div class="control-group">
            <label>基本色 (B):</label>
            <input type="range" id="baseColorB" min="0" max="255" value="200">
            <span id="baseColorBValue">200</span>
        </div>
        <div class="control-group">
            <label>光の色 (R):</label>
            <input type="range" id="lightColorR" min="0" max="255" value="150">
            <span id="lightColorRValue">150</span>
        </div>
        <div class="control-group">
            <label>光の色 (G):</label>
            <input type="range" id="lightColorG" min="0" max="255" value="255">
            <span id="lightColorGValue">255</span>
        </div>
        <div class="control-group">
            <label>光の色 (B):</label>
            <input type="range" id="lightColorB" min="0" max="255" value="255">
            <span id="lightColorBValue">255</span>
        </div>
        <div class="control-group">
            <label>波の細かさ:</label>
            <input type="range" id="waveScale" min="0.5" max="10" value="3" step="0.1">
            <span id="waveScaleValue">3</span>
        </div>
        <div class="control-group">
            <label>揺らぎの速度:</label>
            <input type="range" id="waveSpeed" min="0" max="2" value="0.5" step="0.05">
            <span id="waveSpeedValue">0.5</span>
        </div>
        <div class="control-group">
            <label>光の強度:</label>
            <input type="range" id="lightIntensity" min="0" max="2" value="1" step="0.1">
            <span id="lightIntensityValue">1</span>
        </div>
        <div class="control-group">
            <label>歪みの強さ:</label>
            <input type="range" id="distortion" min="0" max="0.5" value="0.15" step="0.01">
            <span id="distortionValue">0.15</span>
        </div>
        <div class="control-group">
            <label>コントラスト:</label>
            <input type="range" id="contrast" min="0.5" max="3" value="1.5" step="0.1">
            <span id="contrastValue">1.5</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGLがサポートされていません');
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = (a_position + 1.0) * 0.5;
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec3 u_baseColor;
            uniform vec3 u_lightColor;
            uniform float u_waveScale;
            uniform float u_waveSpeed;
            uniform float u_lightIntensity;
            uniform float u_distortion;
            uniform float u_contrast;
            
            varying vec2 v_texCoord;
            
            // ノイズ関数
            vec3 mod289(vec3 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }
            
            vec2 mod289(vec2 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }
            
            vec3 permute(vec3 x) {
                return mod289(((x*34.0)+1.0)*x);
            }
            
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187,
                                    0.366025403784439,
                                    -0.577350269189626,
                                    0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy));
                vec2 x0 = v -   i + dot(i, C.xx);
                
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                
                i = mod289(i);
                vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                    + i.x + vec3(0.0, i1.x, 1.0));
                
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m;
                m = m*m;
                
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                
                m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
                        float waterCaustics(vec2 uv, float time) {
                vec2 p = uv * u_waveScale;
                float t = time * u_waveSpeed;
                
                // 複数のノイズを重ね合わせて複雑な波を作成
                float n1 = snoise(p + vec2(t * 0.7, t * 0.5));
                float n2 = snoise(p * 1.5 + vec2(t * -0.5, t * 0.8));
                float n3 = snoise(p * 2.3 + vec2(t * 0.3, t * -0.6));
                float n4 = snoise(p * 0.7 + vec2(t * -0.8, t * 0.4));
                
                // ノイズを組み合わせ
                float noise = n1 * 0.4 + n2 * 0.3 + n3 * 0.2 + n4 * 0.1;
                
                vec2 distortedUV = uv + noise * u_distortion;
                
                float pattern1 = sin(distortedUV.x * 30.0 + noise * 5.0 + t * 2.0);
                float pattern2 = sin(distortedUV.y * 25.0 + noise * 4.0 - t * 1.8);
                float pattern3 = sin((distortedUV.x + distortedUV.y) * 20.0 + noise * 3.0 + t * 1.5);
                
                float caustics = pattern1 * pattern2 * 0.5 + pattern3 * 0.5;
                caustics = pow(abs(caustics), u_contrast);
                
                return caustics;
            }
            
            void main() {
                vec2 uv = v_texCoord;
                float time = u_time;
                
                // コースティクス効果を計算
                float caustics = waterCaustics(uv, time);
                
                // 追加の細かい波紋
                float ripples = waterCaustics(uv * 3.0, time * 1.5) * 0.3;
                caustics += ripples;
                
                // 光の強度を調整
                caustics *= u_lightIntensity;
                
                // 基本色と光の色を混合
                vec3 color = u_baseColor + u_lightColor * caustics;
                
                // 水深による色の変化をシミュレート
                float depth = 1.0 - uv.y * 0.3;
                color *= depth;
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('シェーダーのコンパイルエラー:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('プログラムのリンクエラー:', gl.getProgramInfoLog(program));
        }


        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const baseColorLocation = gl.getUniformLocation(program, 'u_baseColor');
        const lightColorLocation = gl.getUniformLocation(program, 'u_lightColor');
        const waveScaleLocation = gl.getUniformLocation(program, 'u_waveScale');
        const waveSpeedLocation = gl.getUniformLocation(program, 'u_waveSpeed');
        const lightIntensityLocation = gl.getUniformLocation(program, 'u_lightIntensity');
        const distortionLocation = gl.getUniformLocation(program, 'u_distortion');
        const contrastLocation = gl.getUniformLocation(program, 'u_contrast');

        let params = {
            baseColor: [0, 150/255, 200/255],
            lightColor: [150/255, 255/255, 255/255],
            waveScale: 3,
            waveSpeed: 0.5,
            lightIntensity: 1,
            distortion: 0.15,
            contrast: 1.5
        };

        function updateParam(param, index, value) {
            if (index !== undefined) {
                params[param][index] = value / 255;
            } else {
                params[param] = parseFloat(value);
            }
        }

        document.getElementById('baseColorR').addEventListener('input', function() {
            updateParam('baseColor', 0, this.value);
            document.getElementById('baseColorRValue').textContent = this.value;
        });
        
        document.getElementById('baseColorG').addEventListener('input', function() {
            updateParam('baseColor', 1, this.value);
            document.getElementById('baseColorGValue').textContent = this.value;
        });
        
        document.getElementById('baseColorB').addEventListener('input', function() {
            updateParam('baseColor', 2, this.value);
            document.getElementById('baseColorBValue').textContent = this.value;
        });
        
        document.getElementById('lightColorR').addEventListener('input', function() {
            updateParam('lightColor', 0, this.value);
            document.getElementById('lightColorRValue').textContent = this.value;
        });
        
        document.getElementById('lightColorG').addEventListener('input', function() {
            updateParam('lightColor', 1, this.value);
            document.getElementById('lightColorGValue').textContent = this.value;
        });
        
        document.getElementById('lightColorB').addEventListener('input', function() {
            updateParam('lightColor', 2, this.value);
            document.getElementById('lightColorBValue').textContent = this.value;
        });
        
        document.getElementById('waveScale').addEventListener('input', function() {
            updateParam('waveScale', undefined, this.value);
            document.getElementById('waveScaleValue').textContent = this.value;
        });
        
        document.getElementById('waveSpeed').addEventListener('input', function() {
            updateParam('waveSpeed', undefined, this.value);
            document.getElementById('waveSpeedValue').textContent = this.value;
        });
        
        document.getElementById('lightIntensity').addEventListener('input', function() {
            updateParam('lightIntensity', undefined, this.value);
            document.getElementById('lightIntensityValue').textContent = this.value;
        });
        
        document.getElementById('distortion').addEventListener('input', function() {
            updateParam('distortion', undefined, this.value);
            document.getElementById('distortionValue').textContent = this.value;
        });
        
        document.getElementById('contrast').addEventListener('input', function() {
            updateParam('contrast', undefined, this.value);
            document.getElementById('contrastValue').textContent = this.value;
        });


        let startTime = Date.now();
        
        function render() {
            const currentTime = (Date.now() - startTime) * 0.001;
            
            gl.useProgram(program);
            
            gl.uniform1f(timeLocation, currentTime);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform3fv(baseColorLocation, params.baseColor);
            gl.uniform3fv(lightColorLocation, params.lightColor);
            gl.uniform1f(waveScaleLocation, params.waveScale);
            gl.uniform1f(waveSpeedLocation, params.waveSpeed);
            gl.uniform1f(lightIntensityLocation, params.lightIntensity);
            gl.uniform1f(distortionLocation, params.distortion);
            gl.uniform1f(contrastLocation, params.contrast);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        render();
    </script>
</body>
</html>
